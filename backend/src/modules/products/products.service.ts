import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CloudinaryService } from '../cloudinary/cloudinary.service';
import {
  CreateProductDto,
  UpdateProductDto,
  CreateCategoryDto,
  UpdateCategoryDto,
  CreateReviewDto,
} from './dto/products.dto';
// import { CLOUDINARY_FOLDERS } from '../cloudinary/cloudinary.constants'; // (B·∫°n c√≥ th·ªÉ d√πng h·∫±ng s·ªë n√†y)

@Injectable()
export class ProductsService {
  constructor(
    private prisma: PrismaService,
    private cloudinary: CloudinaryService, // üëà ƒê√£ inject
  ) {}

  // ======================================================
  // 0. HELPERS (T·ª´ file g·ªëc c·ªßa b·∫°n)
  // ======================================================

  async findSellerByUserId(userId: string) {
    const seller = await this.prisma.seller.findUnique({
      where: { userId },
    });
    if (!seller) {
      throw new NotFoundException('Seller profile not found');
    }
    return seller;
  }

  async findEnterpriseByUserId(userId: string) {
    const enterprise = await this.prisma.enterprise.findUnique({
      where: { userId },
    });
    if (!enterprise) {
      throw new NotFoundException('Enterprise profile not found');
    }
    return enterprise;
  }

  // ======================================================
  // 1. PRODUCT METHODS (ƒê√É G·ªòP LOGIC ·∫¢NH)
  // ======================================================

  async createProduct(createProductDto: CreateProductDto) {
    // üîΩ Logic g·ªëc c·ªßa b·∫°n (r·∫•t t·ªët) üîΩ
    const category = await this.prisma.category.findUnique({
      where: { id: createProductDto.categoryId },
    });
    if (!category) {
      throw new NotFoundException('Category not found');
    }
    if (!createProductDto.sellerId && !createProductDto.enterpriseId) {
      throw new BadRequestException('Either sellerId or enterpriseId must be provided');
    }
    if (createProductDto.sellerId && createProductDto.enterpriseId) {
      throw new BadRequestException('Product can only belong to either a seller or an enterprise');
    }
    if (createProductDto.sellerId) {
      const seller = await this.prisma.seller.findUnique({
        where: { id: createProductDto.sellerId },
      });
      if (!seller) throw new NotFoundException('Seller not found');
    }
    if (createProductDto.enterpriseId) {
      const enterprise = await this.prisma.enterprise.findUnique({
        where: { id: createProductDto.enterpriseId },
      });
      if (!enterprise) throw new NotFoundException('Enterprise not found');
    }
    // üîº Logic g·ªëc c·ªßa b·∫°n (r·∫•t t·ªët) üîº
    
    const { variants, ...productData } = createProductDto;

    return this.prisma.product.create({
      data: {
        ...productData,
        variants: {
          create: variants || [],
        },
      },
      include: { // üëà Gi·ªØ l·∫°i include g·ªëc
        category: true,
        variants: true,
        enterprise: { select: { id: true, companyName: true, verified: true, officialBrand: true } },
        seller: { select: { id: true, storeName: true, verified: true } },
      },
    });
  }

  async findAllProducts(
    skip?: number,
    take?: number,
    categoryId?: string,
    sellerId?: string,
    enterpriseId?: string,
  ) {
    const where = {
      ...(categoryId && { categoryId }),
      ...(sellerId && { sellerId }),
      ...(enterpriseId && { enterpriseId }),
    };

    return this.prisma.product.findMany({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where,
      skip,
      take,
      include: {
        category: true,
        variants: true,
        enterprise: { select: { id: true, companyName: true, verified: true, officialBrand: true } },
        seller: { select: { id: true, storeName: true, verified: true } },
      },
    });
  }

  async findOneProduct(id: string) {
    const product = await this.prisma.product.findUnique({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where: { id },
      include: {
        category: true,
        variants: true,
        enterprise: { select: { id: true, companyName: true, verified: true, officialBrand: true } },
        seller: { select: { id: true, storeName: true, verified: true } },
        reviews: {
          include: {
            user: { select: { id: true, name: true } },
          },
        },
      },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    return product;
  }

  async updateProduct(
    id: string,
    ownerId: string, // sellerId ho·∫∑c enterpriseId
    updateProductDto: UpdateProductDto,
  ) {
    const product = await this.prisma.product.findUnique({
      where: { id },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    if (product.sellerId !== ownerId && product.enterpriseId !== ownerId) {
      throw new BadRequestException('You can only update your own products');
    }
    return this.prisma.product.update({
      where: { id },
      data: updateProductDto,
      include: {
        category: true,
        variants: true,
      },
    });
  }

  /**
   * üöÄ LOGIC M·ªöI: T·∫£i ·∫£nh l√™n cho s·∫£n ph·∫©m
   */
  async uploadProductImages(
    productId: string,
    ownerId: string, // sellerId ho·∫∑c enterpriseId
    files: Express.Multer.File[],
  ) {
    const product = await this.prisma.product.findUnique({
      where: { id: productId },
    });
    if (!product) {
      throw new NotFoundException('Product not found');
    }
    if (product.sellerId !== ownerId && product.enterpriseId !== ownerId) {
      throw new BadRequestException('You can only upload images for your own products');
    }

    const uploadedImages = await Promise.all(
  files.map((file) => this.cloudinary.uploadFile(file, { folder: 'products' })), // üëà 2 tham s·ªë
);

    const imageUrls = uploadedImages.map((result) => result.secure_url);

    return this.prisma.product.update({
      where: { id: productId },
      data: {
        images: {
          push: imageUrls,
        },
      },
    });
  }

  /**
   * üöÄ LOGIC M·ªöI: X√≥a 1 ·∫£nh c·ªßa s·∫£n ph·∫©m
   */
  async deleteProductImage(
    productId: string,
    ownerId: string, // sellerId ho·∫∑c enterpriseId
    imageUrl: string,
  ) {
    const product = await this.prisma.product.findUnique({
      where: { id: productId },
      select: { images: true, sellerId: true, enterpriseId: true },
    });

    if (!product) throw new NotFoundException('Product not found');
    if (product.sellerId !== ownerId && product.enterpriseId !== ownerId) {
      throw new BadRequestException('Action not allowed');
    }
    if (!product.images.includes(imageUrl)) {
      throw new NotFoundException('Image not found in product');
    }

    // 1. X√≥a kh·ªèi Cloudinary
    try {
      const publicId = this.cloudinary.getPublicIdFromUrl(imageUrl);
      if (publicId) {
        await this.cloudinary.deleteFile(publicId);
      }
    } catch (error) {
      console.error('Error deleting image from Cloudinary:', error);
    }

    // 2. X√≥a kh·ªèi CSDL
    const updatedImages = product.images.filter((url) => url !== imageUrl);
    return this.prisma.product.update({
      where: { id: productId },
      data: {
        images: updatedImages,
      },
    });
  }

  /**
   * üöÄ LOGIC ƒê√É S·ª¨A: X√≥a s·∫£n ph·∫©m (bao g·ªìm c·∫£ ·∫£nh)
   */
  async deleteProduct(id: string, ownerId: string) {
¬† ¬† // 1. L·∫•y s·∫£n ph·∫©m V√Ä ·∫£nh
¬† ¬† const product = await this.prisma.product.findUnique({
¬† ¬† ¬† where: { id },
¬† ¬† ¬† select: { // üëà S·ª≠a 'include' th√†nh 'select'
¬† ¬† ¬† ¬† images: true,
¬† ¬† ¬† ¬† sellerId: true, // üëà Ph·∫£i select c·∫£ c√°c tr∆∞·ªùng d√πng ƒë·ªÉ ki·ªÉm tra owner
¬† ¬† ¬† ¬† enterpriseId: true,
¬† ¬† ¬† },
¬† ¬† });

¬† ¬† if (!product) {
¬† ¬† ¬† throw new NotFoundException(`Product with ID ${id} not found`);
¬† ¬† }

¬† ¬† // 2. Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
¬† ¬† if (product.sellerId !== ownerId && product.enterpriseId !== ownerId) {
¬† ¬† ¬† throw new BadRequestException('You can only delete your own products');
¬† ¬† }

¬† ¬† // ... (Ph·∫ßn c√≤n l·∫°i c·ªßa h√†m gi·ªØ nguy√™n)
¬† ¬† // 3. X√≥a t·∫•t c·∫£ ·∫£nh tr√™n Cloudinary
    if (product.images && product.images.length > 0) {
      // ...
    }

    // 4. X√≥a s·∫£n ph·∫©m kh·ªèi CSDL
    await this.prisma.product.delete({
      where: { id },
    });

    return { message: 'Product deleted successfully' };
¬† }

  // ======================================================
  // 2. CATEGORY METHODS (N√™n t√°ch ra CategoryService)
  // ======================================================

  async createCategory(createCategoryDto: CreateCategoryDto) {
    if (createCategoryDto.parentId) { // üëà Gi·ªØ l·∫°i logic g·ªëc
      const parentCategory = await this.prisma.category.findUnique({
        where: { id: createCategoryDto.parentId },
      });
      if (!parentCategory) {
        throw new NotFoundException('Parent category not found');
      }
    }
    return this.prisma.category.create({
      data: createCategoryDto,
      include: {
        parent: true,
        children: true,
      },
    });
  }

  async findAllCategories() {
    return this.prisma.category.findMany({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      include: {
        parent: true,
        children: true,
      },
    });
  }

  async findOneCategory(id: string) {
    const category = await this.prisma.category.findUnique({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where: { id },
      include: {
        parent: true,
        children: true,
        products: {
          include: {
            variants: true,
            seller: { select: { id: true, storeName: true, verified: true } },
            enterprise: { select: { id: true, companyName: true, verified: true, officialBrand: true } },
          },
        },
      },
    });
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async updateCategory(id: string, updateCategoryDto: UpdateCategoryDto) {
    if (updateCategoryDto.parentId) { // üëà Gi·ªØ l·∫°i logic g·ªëc
      const parentCategory = await this.prisma.category.findUnique({
        where: { id: updateCategoryDto.parentId },
      });
      if (!parentCategory) {
        throw new NotFoundException('Parent category not found');
      }
    }
    const category = await this.prisma.category.findUnique({
      where: { id },
    });
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return this.prisma.category.update({
      where: { id },
      data: updateCategoryDto,
      include: {
        parent: true,
        children: true,
      },
    });
  }

  async deleteCategory(id: string) {
    const category = await this.prisma.category.findUnique({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where: { id },
      include: {
        children: true,
        products: true,
      },
    });
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    if (category.children.length > 0) {
      throw new BadRequestException('Cannot delete category with existing subcategories');
    }
    if (category.products.length > 0) {
      throw new BadRequestException('Cannot delete category with existing products');
    }
    await this.prisma.category.delete({
      where: { id },
    });
    return { message: 'Category deleted successfully' };
  }

  // ======================================================
  // 3. REVIEW METHODS (N√™n t√°ch ra ReviewService)
  // ======================================================

  async createReview(
    productId: string,
    userId: string,
    createReviewDto: CreateReviewDto,
  ) {
    const product = await this.prisma.product.findUnique({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where: { id: productId },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${productId} not found`);
    }
    return this.prisma.review.create({
      data: {
        ...createReviewDto,
        productId,
        userId,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });
  }

  async getProductReviews(productId: string) {
    const product = await this.prisma.product.findUnique({ // üëà Gi·ªØ l·∫°i logic g·ªëc
      where: { id: productId },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${productId} not found`);
    }
    return this.prisma.review.findMany({
      where: { productId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });
  }
}